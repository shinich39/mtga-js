<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>index.html</title>
  </head>

  <body>

    <table>
      <thead>
        <tr>
          <th>Ctrl</th>
          <th>Meta</th>
          <th>Shift</th>
          <th>Alt</th>
          <th>Key</th>
        </tr>
      </thead>
      <tbody>
        <tr id="keydown-row">
          <td>false</td>
          <td>false</td>
          <td>false</td>
          <td>false</td>
          <td>false</td>
        </tr>
      </tbody>
    </table>

<textarea id="textarea" style="width: 512px; height: 512px;">
Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
Sed ornare augue nibh, non dignissim felis viverra et.
Integer ex lorem, lobortis at viverra sit amet, imperdiet ac erat.
Maecenas malesuada maximus leo quis posuere.
Mauris placerat viverra ipsum quis sagittis.
Cras laoreet neque tortor. Quisque in maximus eros. 
Vivamus vehicula vestibulum est, in interdum turpis. 
Aenean tempor nulla at sapien suscipit finibus. 
Proin id leo nec nisi eleifend eleifend.</textarea>

    <script src="test/textarea-caret-position.js"></script>
    <script src="dist/mtga.js"></script>
    <script src="example/beautify.js"></script>
    <script>
      const row = document.querySelector("#keydown-row");
      const ctrlEl = row.children[0];
      const metaEl = row.children[1];
      const shiftEl = row.children[2];
      const altEl = row.children[3];
      const keyEl = row.children[4];

      window.addEventListener("keydown", (e) => {
        ctrlEl.innerHTML = e.ctrlKey;
        metaEl.innerHTML = e.metaKey;
        shiftEl.innerHTML = e.shiftKey;
        altEl.innerHTML = e.altKey;
        keyEl.innerHTML = e.key;
      });

      window.addEventListener("keyup", (e) => {
        ctrlEl.innerHTML = e.ctrlKey;
        metaEl.innerHTML = e.metaKey;
        shiftEl.innerHTML = e.shiftKey;
        altEl.innerHTML = e.altKey;
        keyEl.innerHTML = e.key;
      });
      
    </script>
    <script>
      const MAX_ITEM_COUNT = 100;
      const VISIBLE_COUNT = 11;

      console.log("window.MtgaJs", window.MtgaJs);

      const {
        MTGA,
        AutoCompleteModule,
        CommentModule,
        HistoryModule,
        IndentModule,
        LineBreakModule,
        LineRemoveModule,
      } = window.MtgaJs;

      const mtga = new MTGA(document.getElementById("textarea"));

      console.log("MTGA", mtga);

      mtga.setModule(new window.BeautifyModule(mtga));
      console.log("BeautifyModule", mtga.getModule(window.BeautifyModule.name));

      const h = mtga.getModule(HistoryModule.name);
      const ac = mtga.getModule(AutoCompleteModule.name);
      console.log("AutoCompleteModule", ac);

      // set tags for AutoComplete
      const tags = [];
      for (let i = 0; i < 1000; i++) {
        tags.push(
          { key: "john_doe", value: "John Doe" },
          { key: "jane_smith", value: "Jane Smith" },
          { key: "michael_johnson", value: "Michael Johnson" },
          { key: "emily_davis", value: "Emily Davis" },
          { key: "daniel_wilson", value: "Daniel Wilson" },
          { key: "sarah_miller", value: "Sarah Miller" },
          { key: "david_brown", value: "David Brown" },
          { key: "olivia_jones", value: "Olivia Jones" },
          { key: "james_garcia", value: "James Garcia" },
          { key: "emma_martinez", value: "Emma Martinez" },      
        );
      }
      ac.tags = tags;

      // indexing
      console.time("indexing");

      for (const tag of tags) {
        const found = ac.indexes.find(({ pattern }) => 
          pattern.test(tag.key));

        if (found) {
          found.tags.push(tag);
        } else {
          ac.indexes.push({
            pattern: new RegExp("^"+tag.key[0]),
            tags: [tag],
          });
        }
      }

      console.timeEnd("indexing");
      console.log("indexes:", ac.indexes);

      // Render auto-complete items
      ;(() => {
        const listEl = document.createElement("div");
        listEl.style.position = "absolute";
        listEl.style.visibility = "hidden";
        listEl.style.backgroundColor = "#FFF";
        listEl.style.borderTop = "1px solid";
        listEl.style.borderLeft = "1px solid";
        document.body.appendChild(listEl);

        let items = [],
            index = 0;

        const origParser = ac.parser;
        ac.parser = function (e) {
          // console.log("parser", e);
          const r = origParser(e);

          // don't block current searching
          hide(false);
          
          if (r.body.length < 1 || r.body.length > 39) {
            this.kill()
            return r;
          }

          // prevent auto-complete with backspace key if it is not the last character.
          const el = e.target;
          const isBackspace = e.key.toLowerCase() === "backspace";
          const isLastChar = el.selectionStart === r.head.length + r.body.length;
          if (isBackspace && !isLastChar) {
            this.kill();
            return r;
          }

          r.body = r.body.toLowerCase().replace(/\s/g, "_");

          return r;
        }

        ac.filter = function (query, tag, i, tags) {
          // console.log("filter", chunk);
          const result = this.result;
          const a = query.body;
          const b = tag.key;

          if (result.length >= MAX_ITEM_COUNT) {
            this.stop();
            return false;
          }

          const { matches } = matchStrings(a, b);

          return matches >= a.length;
        }

        const load = () => {
          if (items[index]?.tag) {
            ac.set(items[index].tag);
          }
        }

        const render = () => {
          let min = Math.max(0, index - VISIBLE_COUNT / 2);
          const max = Math.min(items.length, min + VISIBLE_COUNT);
          if (max - min < VISIBLE_COUNT) {
            min = Math.max(0, max - VISIBLE_COUNT);
          }

          for (let i = 0; i < items.length; i++) {
            const el = items[i].element;
            el.style.color = "";
            el.style.backgroundColor = "";
            if (i >= min && i < max) {
              el.style.display = "";
              if (i === index) {
                el.style.color = "#FFF";
                el.style.backgroundColor = "#000";
              }
            } else {
              el.style.display = "none";
            }
          }
        }
        
        const isShown = () => {
          return listEl.style.visibility === "";
        }

        const show = () => {
          if (!isShown()) {
            const caretPosition = getCaretCoordinates(mtga.element, mtga.element.selectionEnd);
            const taRect = mtga.element.getBoundingClientRect();
            const listRect = listEl.getBoundingClientRect();
            listEl.style.visibility = "";
            listEl.style.zIndex = 3939;
            listEl.style.top = (taRect.top + caretPosition.top + 18) + "px";
            listEl.style.left = Math.min(
              taRect.left + document.documentElement.clientWidth - listRect.width, 
              taRect.left + caretPosition.left - 11,
            ) + "px";
          }
        }

        const hide = (kill = true) => {
          items = [];
          index = 0;
          listEl.innerHTML = "";
          listEl.style.visibility = "hidden";
          if (kill) {
            ac.kill();
          }
        }

        const keydownHandler = (e) => {
          const { key, shiftKey, metaKey, ctrlKey } = e;
          if (isShown()) {
            switch(key) {
              case "z":
              case "Z":
                if (ctrlKey || metaKey) {
                  hide();
                }
                break;
              case "ArrowUp":
                e.preventDefault();
                if (index > 0) {
                  index = Math.max(0, index - 1);
                } else {
                  index = items.length - 1;
                }
                render();
                break;
              case "ArrowDown":
                e.preventDefault();
                if (index < items.length - 1) {
                  index = Math.min(items.length - 1, index + 1);
                } else {
                  index = 0;
                }
                render();
                break;
              case "ArrowLeft":
              case "ArrowRight":
                hide();
                break;
              case "Escape":
                e.preventDefault();
                hide();
                break;
              case "Enter":
                e.preventDefault();
                load();
                hide();
                break;
              default:
                if (e.defaultPrevented) {
                  hide();
                  return;
                }
            }
          }
        }

        ac.onData = function (chunks) {
          if (chunks.length) {
            console.log("onData", chunks);
          }

          const query = this.query;
          
          if (!query) {
            hide();
          }

          // render items
          for (let i = 0; i < chunks.length; i++) {
            const idx = i;
            const tag = chunks[i];
            const diffs = getDiffs(query.body, tag.key);
            const itemEl = document.createElement("div");
            itemEl.style.padding = "2px 4px";
            itemEl.style.cursor = "pointer";
            itemEl.style.borderRight = "1px solid black";
            itemEl.style.borderBottom = "1px solid black";

            let html = `(${items.length}) `;
            for (const [type, value] of diffs) {
              if (type === -1) {
                continue;
              }

              html += type === 0
                ? `<span style="background-color: yellow; color: black;">${value}</span>` 
                : `<span>${value}</span>`;
            }

            itemEl.innerHTML = html;
            itemEl.addEventListener("mousedown", (e) => {
              e.preventDefault();
              if (index !== idx) {
                index = idx;
                render();
              } else {
                load();
                hide();
              }
            });

            items.push({
              tag,
              element: itemEl,
            });

            listEl.appendChild(itemEl);
          }

          if (items.length > 0 && !isShown()) {
            show();
          }

          render();
        }

        ac.onEnd = function() {
          console.log("onEnd", this.result);
        }

        window.addEventListener("keydown", keydownHandler, true);
        mtga.element.addEventListener("click", () => hide());
        mtga.element.addEventListener("blur", () => hide());
      })();
      /**
       * myers algorithm
       *
       * -1: number of deleted characters
       *  0: number of matched characters
       *  1: number of inserted characters
       *
       * @example
       * const result = getDiffs("Lorem", "ore"); // [[-1, "L"], [0, "ore"], [-1, "m"]]
       */
      function getDiffs(from, to) {
        const backtrack = function (from, to, trace, d) {
          const result = [];

          let x = from.length;
          let y = to.length;
          const max = from.length + to.length;

          let currentOp = null;
          let currentStr = "";

          const push = (op, char) => {
            if (currentOp === op) {
              currentStr = char + currentStr;
            } else {
              if (currentOp !== null && currentStr) {
                result.push([currentOp, currentStr]);
              }
              currentOp = op;
              currentStr = char;
            }
          };

          for (let depth = d; depth >= 0; depth--) {
            const v = trace[depth];
            const k = x - y;

            let prevK;

            if (k === -depth || (k !== depth && v[k - 1 + max] < v[k + 1 + max])) {
              prevK = k + 1;
            } else {
              prevK = k - 1;
            }

            const prevX = v[prevK + max];
            const prevY = prevX - prevK;

            // diagonal move (match)
            while (x > prevX && y > prevY) {
              x--;
              y--;
              push(0, from[x]);
            }

            if (depth === 0) break;

            // vertical move (insertion)
            if (x === prevX) {
              y--;
              push(1, to[y]);
            }
            // horizontal move (deletion)
            else {
              x--;
              push(-1, from[x]);
            }
          }

          if (currentOp !== null && currentStr) {
            result.push([currentOp, currentStr]);
          }

          return result.reverse();
        };

        const n = from.length;
        const m = to.length;
        const max = n + m;

        const v = Array(2 * max + 1).fill(0);
        const trace = [];

        for (let d = 0; d <= max; d++) {
          trace.push([...v]);

          for (let k = -d; k <= d; k += 2) {
            let x;

            if (k === -d || (k !== d && v[k - 1 + max] < v[k + 1 + max])) {
              x = v[k + 1 + max];
            } else {
              x = v[k - 1 + max] + 1;
            }

            let y = x - k;

            while (x < n && y < m && from[x] === to[y]) {
              x++;
              y++;
            }

            v[k + max] = x;

            if (x >= n && y >= m) {
              return backtrack(from, to, trace, d);
            }
          }
        }

        return [];
      }
      /**
       * @example
       * const a = "Lorem ipsum dolor sit amet, consectetur adipiscing elit.";
       * const b = "sit amet, adipiscing";
       * const result = matchStrings(a, b);
       * // {
       * //   matchRate: 0.35714285714285715,
       * //   similarity: 0.35714285714285715,
       * //   diceSimilarity: 0.5263157894736842,
       * //   jaccardSimilarity: 0.35714285714285715,
       * //   distance: 36,
       * //   normalizedDistance: 0.6428571428571429,
       * //   matches: 20,
       * //   insertions: 0,
       * //   deletions: 36
       * // }
       */
      function matchStrings(from, to) {
        const diff = getDiffs(from, to);

        let matches = 0;
        let insertions = 0;
        let deletions = 0;

        for (const [op, str] of diff) {
          const len = str.length;
          if (op === 0) {
            matches += len;
          } else if (op === 1) {
            insertions += len;
          } else {
            deletions += len;
          }
        }

        const totalOperations = matches + insertions + deletions;

        return {
          matchRate: totalOperations > 0 ? matches / totalOperations : 1,

          similarity:
            Math.max(from.length, to.length) > 0
              ? matches / Math.max(from.length, to.length)
              : 1,

          diceSimilarity:
            from.length + to.length > 0
              ? (2 * matches) / (from.length + to.length)
              : 1,

          jaccardSimilarity:
            from.length + to.length - matches > 0
              ? matches / (from.length + to.length - matches)
              : 1,

          distance: insertions + deletions,

          normalizedDistance:
            Math.max(from.length, to.length) > 0
              ? (insertions + deletions) / Math.max(from.length, to.length)
              : 0,

          matches,
          insertions,
          deletions,
        };
      }
    </script>
  </body>
</html>
